(define-module (stones game)
  (import (mesche math)
          (mesche string)
          (substratic font)
          (substratic input)
          (substratic renderer)
          (stones ui)
          (stones assets)
          (stones player)
          (stones screen)))

;; Game states:
;; - running
;; - editing

(define state 'running)

(define small-font #f)
(define result-font #f)

(define mouse-x 0)
(define mouse-y 0)

(define player #f)
(define screens '())
(define current-screen #f)
(define last-save-point #f)
(define root-element #f)
(define ui-context #f)

(define screen-scale 1)

(define (screen-by-name screens name)
  (cdr (assq name screens)))

(define (init-game screen-width screen-height scale) :export
  ;; Hold on to the screen size and scale
  (set! ui-context (make-ui-context :pos-x 0
                                    :pos-y 0
                                    :max-x screen-width
                                    :max-y screen-height))
  (set! screen-scale scale)

  ;; Load assets
  (set! small-font (load-font 'small-font "assets/fonts/Thintel.ttf" 35))
  (set! result-font (load-font 'result-font
                               "assets/fonts/Thintel.ttf"
                               150))

  (let ((start #f))
    (save-screen (create-start-screen) "assets/screens/start.stm")
    (set! start (load-screen "assets/screens/start.stm"))

    ;; TODO: Load the screen index
    (set! screens (list (cons "start" start)
                        (cons "left" (create-left-screen))
                        (cons "right" (create-right-screen))
                        (cons "down" (create-down-screen)))))

  ;; TODO: Load the last save point data
  (set! last-save-point (cons "start" (cons 19 17)))

  ;; Set the start screen
  (set! current-screen (screen-by-name screens (car last-save-point)))

  ;; Create the UI
  (set! root-element (create-root-element
                      (create-button "test-button"
                                     "Click me!"
                                     300 300 80
                                     (lambda (ui-element)
                                       (display "I was clicked!\n")))))

  ;; Create and initialize the player
  (let ((start-pos (cdr last-save-point)))
    (set! player (create-player))
    (player-x-set! player (* (car start-pos) tile-size))
    (player-y-set! player (* (cdr start-pos) tile-size))))

(define (screen->world screen-x screen-y)
  (cons (floor (/ screen-x tile-size))
        (floor (/ screen-y tile-size))))

(define (translate-input-event input-event mouse-x mouse-y)
  (if (input-event-mouse-button-down? input-event)
      (make-ui-mouse-event :x mouse-x
                           :y mouse-y
                           :kind 'down
                           :button (input-event-mouse-button input-event))
      (if (input-event-mouse-button-up? input-event)
          (make-ui-mouse-event :x mouse-x
                               :y mouse-y
                               :kind 'up
                               :button (input-event-mouse-button input-event))
          (if (input-event-mouse-move? input-event)
              (make-ui-mouse-event :x mouse-x
                                   :y mouse-y
                                   :kind 'move)))))

(define (handle-game-input-event input-event) :export
  ;; Track current mouse position
  (if (input-event-mouse-move? input-event)
      (begin
        (set! mouse-x (/ (input-event-mouse-x input-event) screen-scale))
        (set! mouse-y (/ (input-event-mouse-y input-event) screen-scale))))

  ;; Did the player click the mouse in edit mode?
  ;; (if (and (equal? state 'editing)
  ;;          (input-event-mouse-button-down? input-event)
  ;;          (equal? (input-event-mouse-button input-event)
  ;;                  input-mouse-button-left))
  ;;     (let ((map-pos (screen->world mouse-x mouse-y)))
  ;;       (screen-tile-set! current-screen
  ;;                         (car map-pos)
  ;;                         (cdr map-pos)
  ;;                         1)))

  ;; Are we toggling edit mode?
  (if (and (input-event-key-down? input-event)
           (equal? (input-event-key-code input-event)
                   input-key-code-tab))
      (begin
        (set! state (if (equal? state 'running)
                        'editing
                        'running))
        (display (string-append "Mode toggled to '"
                                (symbol->string state)
                                "'\n"))))

  (if (equal? state 'editing)
      (if (and (input-event-key-down? input-event)
               (input-event-modifier-ctrl? input-event)
               (equal? (input-event-key-code input-event)
                       input-key-code-s))
          (begin
            ;; (display "About to save...\n")
            (save-screen current-screen (string-append "assets/screens/"
                                                       (screen-name current-screen)
                                                       ".stm"))
            (display "Saved the screen!\n"))

          ;; Translate the input event to screen space
          (handle-element ui-context
                          root-element
                          (translate-input-event input-event mouse-x mouse-y)))

      ;; If not editing, handle player input
      (handle-player-input player input-event)))

(define (game-event-handler event)
  (if (equal? (car event) 'change-screen)
      (let ((portal (cdr event)))
        (set! current-screen (screen-by-name screens (portal-dest-screen portal)))
        ;; TODO: Set player position to portal
        (display "MOVING TO SCREEN: ")
        (display (portal-dest-screen portal))
        (display "\n")
        ;; (screen-portal-by-name current-screen (portal-dest-portal portal))
        )))

(define (update-game time-delta) :export
  (if (eqv? state 'quit)
      ;; If we're in the quit state, exit the loop by returning nil
      #f
      (begin
        ;; Continue running the game loop
        ;; (update-element ui-context root-element time-delta)
        (update-player player current-screen game-event-handler time-delta)
        #t)))

(define (render-text-centered renderer
                              font
                              text
                              x y
                              text-width text-height)
  (render-text renderer
               font
               text
               (- x (/ text-width 2))
               (- y (/ text-height 2))))

(define (render-game renderer window-width window-height) :export
  (render-screen renderer current-screen window-width window-height)
  (render-player renderer player window-width window-height)

  (render-text renderer
               small-font
               (string-append "MX: "
                              (number->string (floor (/ mouse-x tile-size)))
                              " / MY: "
                              (number->string (floor (/ mouse-y tile-size))))
               10 30)

  (render-text renderer
               small-font
               (string-append "STATE: " (symbol->string state))
               10 50)

  ;; Render the UI
  (render-element ui-context root-element renderer))
